#! /usr/bin/perl

## zfsync - synchronize latest snapshot from a source to a target using ZFS incremental rollup snapshots (zfs send -R -I).

## temp format: zfsync [[user@]host:]source target [-z]
## the -z argument adds ZFS compression.
## sources in the format host:path or user@host:path will add SSH transport.
##
## example: zfsync root@localhost:locutus/source locutus/target

# require IO::Handle;

use Sys::Hostname;

# Yay gzip!  Yay conserved network bandwidth! 
# Feel free to turn this off if you hate your network.
# And fun.  And puppies.
$use_gz = 1;

# A local copy of mbuffer really whips the llama's ass -
# even with a mere 64M allocated, it pretty much doubled
# a real-world replication speed of a day's worth of data
# at roughly 1.5G total to xfer for me.
#
# Note: zfsync will automatically find mbuffer on the
# local machine if it's available, and use the correct
# path.  If you enable it here and don't actually have it,
# zfsync will quietly disable it for you.  And curse you
# under its breath.
$use_local_mbuffer = 1;
$local_mbuffer_size = '128M';

# Remote mbuffer is probably not as big a win.  Over a WAN
# link it will improve performance over local mbuffer alone,
# but it does zero good over a LAN connection.
# Also, ugly stupid message about tape drives, wtf.
# And be damn careful that it both exists and you've got the
# right path to it on your remote machine, because I have not
# yet built in automated checks to find it!
$use_remote_mbuffer = 1;
$remote_mbuffer_size = '128M';
$remote_mbuffer = "/usr/bin/mbuffer";

$source = $ARGV[0];
$target = $ARGV[1];

if ($use_gz) {
	$compress = 1;
	$gzip = '| /bin/gzip -3';
	$zcat = '| /bin/zcat';
}

if ($source =~ /^\S*:/) {
	# ssh source
	$sourcehost = $source;
	$sourcehost =~ s/:.*$//;
	$source =~ s/^\S*://;
	$ssh = "/usr/bin/ssh -c arcfour $sourcehost";
}

# find the zfs command 
if (-e '/sbin/zfs') { $zfs = '/sbin/zfs'; }
elsif (-e '/bin/zfs') { $zfs = '/bin/zfs'; }
elsif (-e '/usr/sbin/zfs') { $zfs = '/usr/sbin/zfs'; }
elsif (-e '/usr/bin/zfs') { $zfs = '/usr/bin/zfs'; }
elsif (-e '/usr/local/sbin/zfs') { $zfs = '/usr/local/sbin/zfs'; }
elsif (-e '/usr/local/bin/zfs') { $zfs = '/usr/local/bin/zfs'; }
elsif (-e '/opt/zfs') { $zfs = '/opt/zfs'; }
elsif (-e '/usr/local/opt/zfs') { $zfs = '/usr/local/opt/zfs'; }

# if we have pv available on the system, let's find it and use it.
if (-e '/sbin/pv') { $pv = '/sbin/pv'; }
elsif (-e '/bin/pv') { $pv = '/bin/pv'; }
elsif (-e '/usr/sbin/pv') { $pv = '/usr/sbin/pv'; }
elsif (-e '/usr/bin/pv') { $pv = '/usr/bin/pv'; }
elsif (-e '/usr/local/sbin/pv') { $pv = '/usr/local/sbin/pv'; }
elsif (-e '/usr/local/bin/pv') { $pv = '/usr/local/bin/pv'; }
elsif (-e '/opt/pv') { $pv = '/opt/pv'; }
elsif (-e '/usr/local/opt/pv') { $pv = '/usr/local/opt/pv'; }

# if we have mbuffer available on the system, let's find it and use it.
if (-e '/sbin/mbuffer') { $local_mbuffer = '/sbin/mbuffer'; }
elsif (-e '/bin/mbuffer') { $local_mbuffer = '/bin/mbuffer'; }
elsif (-e '/usr/sbin/mbuffer') { $local_mbuffer = '/usr/sbin/mbuffer'; }
elsif (-e '/usr/bin/mbuffer') { $local_mbuffer = '/usr/bin/mbuffer'; }
elsif (-e '/usr/local/sbin/mbuffer') { $local_mbuffer = '/usr/local/sbin/mbuffer'; }
elsif (-e '/usr/local/bin/mbuffer') { $local_mbuffer = '/usr/local/bin/mbuffer'; }
elsif (-e '/opt/mbuffer') { $local_mbuffer = '/opt/mbuffer'; }
elsif (-e '/usr/local/opt/mbuffer') { $local_mbuffer = '/usr/local/opt/mbuffer'; }
else { $use_local_mbuffer = 0; }

$local_mbuffer .= " -q -s 128k -m $local_mbuffer_size";
$remote_mbuffer .= " -q -s 128k -m $remote_mbuffer_size";

$hostid = hostname;

my @dateparts = &get_date;
my $datestamp = $dateparts[4];

# get a list of zfsync snapshots from the source
#print STDERR "Getting list of snapshots from source...\n";
@sourcesnaps = `$ssh $zfs list -rH -t snapshot -o name $source`;

#print "@sourcesnaps\n\n";

# building a single command to get the list of creation,referenced for each snapshot on source.
# we'll run the command on the target once it's built.
# this avoids unnecessary SSH tunnel creation overhead.
my $cmd;
foreach $sourcesnap(@sourcesnaps) {
	chomp $sourcesnap;
	$cmd .= "$zfs get -Hp -o name,property,value creation,referenced $sourcesnap; ";
}
#print STDERR "Getting details on source snapshots... ";
@sourcesnaprawdetails = `$ssh '$cmd'`;
#print STDERR "details received.\n";

# build a hash for the source snapshot details.
foreach $ssrow (@sourcesnaprawdetails) {
	@ssrow = split " ",$ssrow;
	# we only want the snapshot ID, not the zfs pathname
	$ssrow[0] =~ s/^.*?\@//;
	$ssdetails {$ssrow[0]}{$ssrow[1]} = $ssrow[2];
}

#print "Hash built:\n";
#foreach $name ( sort { $ssdetails{$b}{'creation'} <=> $ssdetails{$a}{'creation'} } keys %ssdetails ) {
#	print "name: $name creation: $ssdetails{$name}{'creation'} referenced: $ssdetails{$name}{'referenced'}\n";
#}

# does the target exist yet?
@targetexists = `$zfs list -o name`;
while (my $snap = pop(@targetexists)) { 
	chomp $snap;
	if ($snap eq $target) { $targetexists=1; }
}

if ($targetexists) { 
	#print STDERR "Target exists.  Finding snapshots... ";
	@targetsnaps = `$zfs list -rH -t snapshot -S creation -o name $target`;
	$numtargetsnaps = scalar @targetsnaps;
	#print STDERR "found $numtargetsnaps snapshots on target.\n";

	if (! $numtargetsnaps) {
		# we're going destroy target if we don't have any snapshots on it
		print STDERR "No snapshots on target: destroying target.\n";
		system ("$zfs destroy -r $target");
		$targetexists = 0;
	} else {
		# we have snapshots, now we need details to match up with the source
		my $cmd;
		foreach $targetsnap (@targetsnaps) {
		        chomp $targetsnap;
		        $cmd .= "$zfs get -Hp -o name,property,value creation,referenced $targetsnap; ";
		}

		#print STDERR "Getting details on target snapshots... ";
		@targetsnaprawdetails = `$cmd`;
		#print STDERR "details received.\n";
		
		# build a hash for the target snapshot details.
		foreach $tsrow (@targetsnaprawdetails) {
		        @tsrow = split " ",$tsrow;
			# we only want the snapshot ID, not the zfs pathname
			$tsrow[0] =~ s/^.*?\@//;
		        $tsdetails {$tsrow[0]}{$tsrow[1]} = $tsrow[2];
		}

		#foreach $name ( sort { $tsdetails{$b}{'creation'} <=> $tsdetails{$a}{'creation'} } keys %tsdetails ) {
                #	print "name: $name creation: $tsdetails{$name}{'creation'} referenced: $tsdetails{$name}{'referenced'}\n";
		#}
	}
}

if ($numtargetsnaps) {
	# make sure we have a snap on the source to match a targetsnap
	#print STDERR "Attempting to match zfsync snapshots on source and target.\n";
	# iterate the target hash in reverse creation order (ie, newest creation first)
	foreach $name ( sort { $tsdetails{$b}{'creation'} <=> $tsdetails{$a}{'creation'} } keys %tsdetails ) {
	        #print "name: $name creation: $tsdetails{$name}{'creation'} referenced: $tsdetails{$name}{'referenced'}\n";
		if (
		     ! $matched
		     && $tsdetails{$name}{'creation'} == $ssdetails{$name}{'creation'}
		     #&& $tsdetails{$name}{'referenced'} == $ssdetails {$name}{'referenced'}
		   ) {
			#print STDERR "Match found: snapshot $name exists with same creation on source and target.\n";
			$matched = 1;
			$oldsnap = $name;
          
			$used = `$ssh zfs diff $source\@$name $source`;
			if ($used eq '') {
				#print STDERR "No new data on $source since \@$name - nothing to sync, exiting.\n";
				print STDERR "No new data on $source to sync, exiting.\n";
				exit 0;
			} 
		}	
	}

	# we're going to have to destroy target if there are no source zfsync snaps
	if (! $matched) {
		print STDERR "No matching zfsync snaps between source and target: committing seppuku now.\n";
		exit 3;
		system ("$zfs destroy -r $target");
		$targetexists = 0;
	}
}	

# create zfsync snapshot on the source
$newsnap = "zfsync\_$hostid\_$datestamp";
print STDERR "Creating $newsnap on $source...\n";
system("$ssh $zfs snapshot $source\@$newsnap");

if (! $targetexists) {
	# Woo, first sync... this'll be a hot minute, amirite?
	print STDERR "$target does not exist - will be created with initial transfer.\n";
	@sendsize = `$ssh $zfs send -nP -R $source\@$newsnap 2>&1`;
	$SOURCE = "$ssh \'$zfs send -R $source\@$newsnap $gzip \' $zcat ";
} else {
	# incremental send yo.  rollback the target to the newest matched snapshot first.
	print STDERR "Rolling $target back to \@$oldsnap before transfer.\n";
	system ("$zfs rollback $target\@$oldsnap");
	@sendsize = `$ssh zfs send -nP -R -I $source\@$oldsnap $source\@$newsnap 2>&1`;
	$SOURCE = "$ssh \'$zfs send -R -I $source\@$oldsnap $source\@$newsnap $gzip \' $zcat ";
}

# process sendsize: last line is summary, remove human-readable crap from it to get xfer estimate in bytes
$sendsize = pop(@sendsize);		
$sendsize =~ s/^size\s*//;
chomp $sendsize;

if ($pv =~ /pv/) { $pv = "$pv -s $sendsize |"; }

$TARGET = "$pv $zfs receive $target";

if ($use_local_mbuffer) {
	$SOURCE =~ s/\' /\' \| $local_mbuffer /;
}

if ($use_remote_mbuffer) {
	$SOURCE =~ s/\' /\| $remote_mbuffer \' /;
}

#print STDERR "\nEffective command: $SOURCE | $TARGET\n\n";

open SOURCE, "$SOURCE |"
        or print $! ? "Error opening zfs send: $!"
        : "Exit status $? from zfs send";
binmode SOURCE;

open TARGET, "| $TARGET"
        or print $! ? "Error opening zfs receive: $!"
        : "Exit status $? from zfs receive";
binmode TARGET;

$blocksize = 65536;
#$blocksize = 1048576;

print STDERR "Transferring approximately " . sprintf("%.1f",$sendsize/1024/1024) . " MB...\n\n";

while ($bufsize = read (SOURCE, $buffer, $blocksize)) {
	$xferred += $bufsize;
	print TARGET $buffer
        	or die $! ? "Error writing to zfs receive: $!"
	        : "Exit status $? from zfs receive";

	if (! ($pv =~ /pv/) ) {
		# ugly, rough homemade progress meter
		print STDERR "Transferred " . sprintf("%.1f",$xferred/1024/1024) . " MB (~ " . sprintf("%.2f",$xferred/$sendsize*100*.999) . "%)\n";
		print STDERR "\e[A";
	}
}

close SOURCE
	or print $! ? "Error closing zfs send: $!"
	: "Exit status $? from zfs send";
close TARGET
	or print $! ? "Error closing zfs receive: $!"
	: "Exit status $? from zfs receive";

$success = `$zfs list -t snap $target\@$newsnap`;

if ($success) { 
	#print STDERR "\nPruning old zfsync snaps on $source... ";
	my $cmd;
	foreach $name ( sort { $ssdetails{$b}{'creation'} <=> $ssdetails{$a}{'creation'} } keys %ssdetails ) {
		if ($name =~ /zfsync\_$hostid/) {
			$cmd .= "$zfs destroy $source\@$name ; ";
		}
	}
	system ("$ssh '$cmd'");
	#print STDERR "old zfsync snaps on $source pruned.\n";

	#print STDERR "Pruning old zfsync snaps on $target... ";
	foreach $name ( sort { $tsdetails{$b}{'creation'} <=> $tsdetails{$a}{'creation'} } keys %tsdetails ) {
		if ($name =~ /zfsync_$hostid/) {
			system("$zfs destroy $target\@$name");
		}
	}
	#print STDERR "old zfsync snaps on $target pruned.\n";

	print "\nTransfer complete! Updated $target from \@$oldsnap to \@$newsnap.\n"; 
	exit 0;
} else { 
	# well, we crashed and burned - but did we get ANY snapshots successfully replicated before we did?
	my @newtargetsnap = `zfs list -r -t snap -o name -S creation -H $target`;
	$newtargetsnap[0] =~ s/^.*?\@//;
	chomp $newtargetsnap[0];

	print "\nTransfer FAILED!  Died after transferring " . sprintf("%.1f",$xferred/1024/1024) . " of approximately " . sprintf("%.1f",$sendsize/1024/1024) . " MB "; 

	if ($newtargetsnap[0] ne $oldsnap) {
		# Yay, we at least managed SOME replication!
		print "; $target was \@$oldsnap, is now \@$newtargetsnap[0].\n";
	} else {
		# Boo, we completely wasted our time, bandwidth, and storage load ='(
		print ".\n";
	}
	exit 3;
}

exit;

sub get_date {
        ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(time);
        $year = $year + 1900;
        my $unix_time = (((((((($year - 1971) * 365) + $yday) * 24) + $hour) * 60) + $min) * 60) + $sec;
        $sec = sprintf ("%02u", $sec);
        $min = sprintf ("%02u", $min);
        $hour = sprintf ("%02u", $hour);
        $mday = sprintf ("%02u", $mday);
        $mon = sprintf ("%02u", ($mon + 1));
        my $datestamp = "$year-$mon-$mday:$hour:$min:$sec";
        return ($sec,$min,$hour,$unix_time,$datestamp);
}

